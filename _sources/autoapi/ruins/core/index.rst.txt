:py:mod:`ruins.core`
====================

.. py:module:: ruins.core


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   build/index.rst
   cache/index.rst
   config/index.rst
   data_manager/index.rst
   debug_view/index.rst
   i18n/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   ruins.core.Config
   ruins.core.DataManager



Functions
~~~~~~~~~

.. autoapisummary::

   ruins.core.build_config
   ruins.core.download_data_archive



.. py:class:: Config(path: str = None, **kwargs)

   Bases: :py:obj:`collections.abc.Mapping`

   Streamlit app Config object.

   This class holds all configs needed to run the apps.
   It can be instantiated just like this to load default
   values.
   If a path is provided, it will load the configs from
   the referenced json file. Any config can be updated
   by passed kwargs.

   This design makes the config updateable and easy to
   to manage. At the same time it can be persisted to
   the disk and even mirrored to a database if needed in
   the future.


   .. py:method:: debug()
      :property:


   .. py:method:: story_mode()
      :property:


   .. py:method:: from_json(path: str) -> dict

      loads the content of the JSON config file


   .. py:method:: _update(new_settings: dict) -> None

      Update this instance with new settings


   .. py:method:: get_control_policy(control_name: str) -> str

      Get the control policy for the given control name.

      allowed policies are:
          - show: always show the control on the main container
          - hide: hide the control on the main container, but move to the expander
          - ignore: don't show anything



   .. py:method:: translator(**translations: Dict[str, str]) -> Callable[[str], str]

      Return a translator function


   .. py:method:: get(key: str, default=None)

      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.


   .. py:method:: has_key(key) -> bool


   .. py:method:: __len__() -> int


   .. py:method:: __iter__()


   .. py:method:: __getitem__(key: str)


   .. py:method:: __setitem__(key: str, value)



.. py:class:: DataManager(datapath: str = None, cache: bool = True, hot_load=False, debug: bool = False, **kwargs)

   Bases: :py:obj:`collections.abc.Mapping`

   Main class for accessing different data sources.

   The DataManager holds and manages all data sources. The default behavior is
   to scan the specified path for files of known file extension and cache them
   in memory.

   :param datapath: A location where the data is stored. The class will load all sources
                    there and make them accessible through DataSource classes.
   :type datapath: str
   :param cache: Will be passed to the DataSource classes. It true, the source will only
                 be read once and then stored in memory until the DataManager gets
                 deconstructed.
   :type cache: bool
   :param include_mimes: A dictionary of file extensions and their corresponding DataSource.
                         If something is not listed, the DataManager will ignore the file type.
                         The include_mimes can be overwritten by passing filenames directly.
   :type include_mimes: dict

   .. py:method:: read(name_or_file: str)


   .. py:method:: from_config(datapath: str = None, cache: bool = True, hot_load: bool = False, debug: bool = False, **kwargs) -> None

      Initialize the DataManager from a :class:`Config <ruins.core.Config>` object.


   .. py:method:: datapath() -> str
      :property:


   .. py:method:: datasources() -> List[DataSource]
      :property:


   .. py:method:: _infer_from_folder() -> None

      Read all files from the datapath as specified on instantiation.
      Calls :func:`add_source` on each file.


   .. py:method:: add_source(path: str, not_exists: str = 'raise') -> None

      Add a file as data source to the DataManager.
      Only if the file has an allowed file extension, it will be managed.
      Files of same name will be overwritten, this is also true if they had
      different extensions.



   .. py:method:: resolve_class_name(cls_name: str) -> Type[DataSource]


   .. py:method:: __len__()

      Return the number of managed data sources


   .. py:method:: __iter__()

      Iterate over all dataset names


   .. py:method:: __getitem__(key: str) -> DataSource

      Return the requested datasource


   .. py:method:: __repr__()

      Return repr(self).


   .. py:method:: __str__()

      Return str(self).



.. py:function:: build_config(omit_dataManager: bool = False, url_params: Dict[str, List[str]] = {}, **kwargs) -> Tuple[ruins.core.config.Config, Union[None, ruins.core.data_manager.DataManager]]

   


.. py:function:: download_data_archive(path: str = None, url: str = 'http://116.203.189.3/data.zip', DOI: str = None, if_exists: str = 'error')

   Download the data archive and extract into the data folder.
   If the path is None, the default path inside the repo itself is used.
   Then, you also need to change the datapath property of the application config.
   If the data folder already exists and is not empty, the function will error on default.
   You can pass ``if_exists='prune'`` to remove the existing data folder and replace it with the new one.


